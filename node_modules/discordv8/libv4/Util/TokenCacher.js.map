{"version":3,"sources":["../../src/Util/TokenCacher.js"],"names":["savePaths","process","env","APPDATA","platform","HOME","cwd","algo","secureEmail","email","password","Buffer","createHash","update","digest","toString","exists","path","accessSync","e","TokenCacher","client","options","savePath","error","done","data","token","cipher","createCipher","crypted","final","save","writeFile","JSON","stringify","decipher","createDecipher","dec","indexOf","substr","ind","self","stat","err","dirStats","storeDirPath","filePath","mkdirSync","closeSync","openSync","readFileSync","parse","emit","writeFileSync","init"],"mappings":"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","file":"TokenCacher.js","sourcesContent":["\"use strict\";\n/* global process */\n\nimport fs from \"fs\";\nimport EventEmitter from \"events\";\nimport crypto from \"crypto\";\n\nvar savePaths = [\n\tprocess.env.APPDATA || (process.platform == \"darwin\" ? process.env.HOME + \"Library/Preferences\" : \"/var/local\"),\n\tprocess.env[(process.platform == \"win32\") ? \"USERPROFILE\" : \"HOME\"],\n\tprocess.cwd(),\n\t\"/tmp\"\n];\n\nvar algo = \"aes-256-ctr\";\n\nfunction secureEmail(email, password) {\n\treturn new Buffer(crypto.createHash(\"sha256\").update(email + password, \"utf8\").digest()).toString(\"hex\");\n}\n\nfunction exists(path) {\n\t// Node deprecated the `fs.exists` method apparently...\n\ttry {\n\t\tfs.accessSync(path);\n\t\treturn true;\n\t} catch (e) {\n\t\treturn false;\n\t}\n}\n\nexport default class TokenCacher extends EventEmitter {\n\n\tconstructor(client, options) {\n\t\tsuper();\n\t\tthis.client = client;\n\t\tthis.savePath = null;\n\t\tthis.error = false;\n\t\tthis.done = false;\n\t\tthis.data = {};\n\t}\n\n\tsetToken(email=\"\", password=\"\", token=\"\") {\n\t\temail = secureEmail(email, password);\n\t\tvar cipher = crypto.createCipher(algo, password)\n\t\tvar crypted = cipher.update(\"valid\" + token, \"utf8\", \"hex\")\n\t\tcrypted += cipher.final(\"hex\");\n\t\tthis.data[email] = crypted;\n\t\tthis.save();\n\t}\n\n\tsave() {\n\t\tfs.writeFile(this.savePath, JSON.stringify(this.data));\n\t}\n\n\tgetToken(email=\"\", password=\"\") {\n\n\t\temail = secureEmail(email, password);\n\n\t\tif (this.data[email]) {\n\n\t\t\ttry {\n\t\t\t\tvar decipher = crypto.createDecipher(algo, password)\n\t\t\t\tvar dec = decipher.update(this.data[email], \"hex\", \"utf8\");\n\t\t\t\tdec += decipher.final(\"utf8\");\n\t\t\t\treturn (dec.indexOf(\"valid\") === 0 ? dec.substr(5) : false);\n\t\t\t} catch (e) {\n\t\t\t\t// not a valid token\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t} else {\n\t\t\treturn null;\n\t\t}\n\n\t}\n\n\tinit(ind) {\n\n\t\tvar self = this;\n\t\tvar savePath = savePaths[ind];\n\n\t\t// Use one async function at the beginning, so the entire function is async,\n\t\t// then later use only sync functions to increase readability\n\t\tfs.stat(savePath, (err, dirStats) => {\n\t\t\t// Directory does not exist.\n\t\t\tif (err) error(err);\n\t\t\telse {\n\t\t\t\ttry {\n\t\t\t\t\tvar storeDirPath = savePath + \"/.discordjs\";\n\t\t\t\t\tvar filePath = storeDirPath + \"/tokens.json\";\n\n\t\t\t\t\tif (!exists(storeDirPath)) {\n\t\t\t\t\t\t// First, make sure the directory exists, otherwise the next\n\t\t\t\t\t\t// call will fail.\n\t\t\t\t\t\tfs.mkdirSync(storeDirPath);\n\t\t\t\t\t}\n\t\t\t\t\tif (!exists(filePath)) {\n\t\t\t\t\t\t// This will create an empty file if the file doesn't exist, and error\n\t\t\t\t\t\t// if it does exist. We previously checked that it doesn't exist so we\n\t\t\t\t\t\t// can do this safely.\n\t\t\t\t\t\tfs.closeSync(fs.openSync(filePath, 'wx'))\n\t\t\t\t\t}\n\n\t\t\t\t\tvar data = fs.readFileSync(filePath);\n\t\t\t\t\ttry {\n\t\t\t\t\t\tthis.data = JSON.parse(data);\n\t\t\t\t\t\tthis.savePath = filePath;\n\t\t\t\t\t\tthis.emit('ready');\n\t\t\t\t\t\tthis.done = true;\n\t\t\t\t\t} catch(e) {\n\t\t\t\t\t\t// not valid JSON, make it valid and then write\n\t\t\t\t\t\tfs.writeFileSync(filePath, '{}');\n\t\t\t\t\t\tthis.savePath = filePath;\n\t\t\t\t\t\tthis.emit(\"ready\");\n\t\t\t\t\t\tthis.done = true;\n\t\t\t\t\t}\n\t\t\t\t} catch(e) {\n\t\t\t\t\terror(e);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\tfunction error(e) {\n\t\t\tind++;\n\t\t\tif (!savePaths[ind]) {\n\t\t\t\tself.emit(\"error\");\n\t\t\t\tself.error = e;\n\t\t\t\tself.done = true;\n\t\t\t} else {\n\t\t\t\tself.init(ind);\n\t\t\t}\n\t\t}\n\n\t}\n}\n"]}