{"version":3,"sources":["../../src/Util/TokenCacher.js"],"names":["savePaths","process","env","APPDATA","platform","HOME","cwd","algo","secureEmail","email","password","Buffer","createHash","update","digest","toString","exists","path","accessSync","e","TokenCacher","constructor","client","options","savePath","error","done","data","setToken","token","cipher","createCipher","crypted","final","save","writeFile","JSON","stringify","getToken","decipher","createDecipher","dec","indexOf","substr","init","ind","self","stat","err","dirStats","storeDirPath","filePath","mkdirSync","closeSync","openSync","readFileSync","parse","emit","writeFileSync"],"mappings":"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","file":"TokenCacher.js","sourcesContent":["\"use strict\";\n/* global process */\n\nimport fs from \"fs\";\nimport EventEmitter from \"events\";\nimport crypto from \"crypto\";\n\nvar savePaths = [\n\tprocess.env.APPDATA || (process.platform == \"darwin\" ? process.env.HOME + \"Library/Preferences\" : \"/var/local\"),\n\tprocess.env[(process.platform == \"win32\") ? \"USERPROFILE\" : \"HOME\"],\n\tprocess.cwd(),\n\t\"/tmp\"\n];\n\nvar algo = \"aes-256-ctr\";\n\nfunction secureEmail(email, password) {\n\treturn new Buffer(crypto.createHash(\"sha256\").update(email + password, \"utf8\").digest()).toString(\"hex\");\n}\n\nfunction exists(path) {\n\t// Node deprecated the `fs.exists` method apparently...\n\ttry {\n\t\tfs.accessSync(path);\n\t\treturn true;\n\t} catch (e) {\n\t\treturn false;\n\t}\n}\n\nexport default class TokenCacher extends EventEmitter {\n\n\tconstructor(client, options) {\n\t\tsuper();\n\t\tthis.client = client;\n\t\tthis.savePath = null;\n\t\tthis.error = false;\n\t\tthis.done = false;\n\t\tthis.data = {};\n\t}\n\n\tsetToken(email=\"\", password=\"\", token=\"\") {\n\t\temail = secureEmail(email, password);\n\t\tvar cipher = crypto.createCipher(algo, password)\n\t\tvar crypted = cipher.update(\"valid\" + token, \"utf8\", \"hex\")\n\t\tcrypted += cipher.final(\"hex\");\n\t\tthis.data[email] = crypted;\n\t\tthis.save();\n\t}\n\n\tsave() {\n\t\tfs.writeFile(this.savePath, JSON.stringify(this.data));\n\t}\n\n\tgetToken(email=\"\", password=\"\") {\n\n\t\temail = secureEmail(email, password);\n\n\t\tif (this.data[email]) {\n\n\t\t\ttry {\n\t\t\t\tvar decipher = crypto.createDecipher(algo, password)\n\t\t\t\tvar dec = decipher.update(this.data[email], \"hex\", \"utf8\");\n\t\t\t\tdec += decipher.final(\"utf8\");\n\t\t\t\treturn (dec.indexOf(\"valid\") === 0 ? dec.substr(5) : false);\n\t\t\t} catch (e) {\n\t\t\t\t// not a valid token\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t} else {\n\t\t\treturn null;\n\t\t}\n\n\t}\n\n\tinit(ind) {\n\n\t\tvar self = this;\n\t\tvar savePath = savePaths[ind];\n\n\t\t// Use one async function at the beginning, so the entire function is async,\n\t\t// then later use only sync functions to increase readability\n\t\tfs.stat(savePath, (err, dirStats) => {\n\t\t\t// Directory does not exist.\n\t\t\tif (err) error(err);\n\t\t\telse {\n\t\t\t\ttry {\n\t\t\t\t\tvar storeDirPath = savePath + \"/.discordjs\";\n\t\t\t\t\tvar filePath = storeDirPath + \"/tokens.json\";\n\n\t\t\t\t\tif (!exists(storeDirPath)) {\n\t\t\t\t\t\t// First, make sure the directory exists, otherwise the next\n\t\t\t\t\t\t// call will fail.\n\t\t\t\t\t\tfs.mkdirSync(storeDirPath);\n\t\t\t\t\t}\n\t\t\t\t\tif (!exists(filePath)) {\n\t\t\t\t\t\t// This will create an empty file if the file doesn't exist, and error\n\t\t\t\t\t\t// if it does exist. We previously checked that it doesn't exist so we\n\t\t\t\t\t\t// can do this safely.\n\t\t\t\t\t\tfs.closeSync(fs.openSync(filePath, 'wx'))\n\t\t\t\t\t}\n\n\t\t\t\t\tvar data = fs.readFileSync(filePath);\n\t\t\t\t\ttry {\n\t\t\t\t\t\tthis.data = JSON.parse(data);\n\t\t\t\t\t\tthis.savePath = filePath;\n\t\t\t\t\t\tthis.emit('ready');\n\t\t\t\t\t\tthis.done = true;\n\t\t\t\t\t} catch(e) {\n\t\t\t\t\t\t// not valid JSON, make it valid and then write\n\t\t\t\t\t\tfs.writeFileSync(filePath, '{}');\n\t\t\t\t\t\tthis.savePath = filePath;\n\t\t\t\t\t\tthis.emit(\"ready\");\n\t\t\t\t\t\tthis.done = true;\n\t\t\t\t\t}\n\t\t\t\t} catch(e) {\n\t\t\t\t\terror(e);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\tfunction error(e) {\n\t\t\tind++;\n\t\t\tif (!savePaths[ind]) {\n\t\t\t\tself.emit(\"error\");\n\t\t\t\tself.error = e;\n\t\t\t\tself.done = true;\n\t\t\t} else {\n\t\t\t\tself.init(ind);\n\t\t\t}\n\t\t}\n\n\t}\n}\n"]}